import java.util.HashMap;

/**
 * BinomialHeap
 *
 * An implementation of binomial heap over non-negative integers. Based on
 * exercise from previous semester.
 */
public class BinomialHeap {
	private static HashMap<Integer, HeapNode> hashMap;
	private HeapNode first;
	private HeapNode min;
	private int size;

	public BinomialHeap() {
		this.first = null;
		this.min = null;
		this.size = 0;
	}

	public BinomialHeap(HeapNode first, HeapNode min, int size) {
		this.first = first;
		this.min = min;
		this.size = size;
	}

	/**
	 * public boolean empty()
	 *
	 * precondition: none
	 * 
	 * The method returns true if and only if the heap is empty.
	 * 
	 */
	public boolean empty() {
		return size() == 0;
	}

	/**
	 * public void insert(int value)
	 *
	 * Insert value into the heap
	 *
	 */
	public void insert(int value) {
		HeapNode x = new HeapNode(value);
		x.setSibling(x);
		hashMap.put(value, x);
		BinomialHeap newHeap = new BinomialHeap(x, x, 1);
		meld(newHeap);
	}

	/**
	 * public void deleteMin()
	 *
	 * Delete the minimum value
	 *
	 */
	public void deleteMin() {
		hashMap.remove(this.min.getKey());
		int minSize = (int) Math.pow(2, this.min.getDegree());
		this.size -= minSize;

		HeapNode newFirst, newMin, x;
		BinomialHeap newHeap;

		if (this.min.getChild() != null) {
			newFirst = this.min.getChild().getSibling();
			newMin = newFirst;
			x = newFirst;

			// find the minimum of min's children
			for (int i = 0; i < this.min.getDegree(); i++) {
				x.setParent(null);
				if (x.getKey() < newMin.getKey()) {
					newMin = x;
				}
				x = x.getSibling();
			}

			newHeap = new BinomialHeap(newFirst, newMin, minSize - 1);
		} else {
			// send an empty heap to meld function
			newHeap = new BinomialHeap(null, null, 0);
		}

		if (this.min.getSibling() != null) {
			// find new minimum of the remaining heap
			newMin = this.first;
			x = newMin.getSibling();
			while (x != this.first) {
				if (x != this.min) {
					if (x.getKey() < newMin.getKey()) {
						newMin = x;
					}
					x = x.getSibling();
				}
			}

			// if min was first, assign new first pointer
			if (this.first == this.min) {
				this.first = this.first.getSibling();
			}

			// delete sibling pointers to min
			x = this.first;
			while (x.getSibling() != this.min) {
				x = x.getSibling();
			}
			x.setSibling(this.min.getSibling());

			this.min = newMin;
		} else {
			this.first = null;
			this.min = null;
		}

		meld(newHeap);
	}

	/**
	 * public int findMin()
	 *
	 * Return the minimum value
	 *
	 */
	public int findMin() {
		return this.min.getKey();
	}

	/**
	 * link two binomial trees of the same degree
	 */
	private HeapNode link(HeapNode root1, HeapNode root2) {
		if (root1 == null) {
			return root2;
		} else if (root2 == null) {
			return root1;
		}
		if (root1.getKey() > root2.getKey()) {
			// replace root1 and root2 pointers
			HeapNode temp = root1;
			root1 = root2;
			root2 = temp;
		}
		if (root1.getChild() == null) {
			// if root1 has no children
			root2.setSibling(root2);
		} else {
			root2.setSibling(root1.getChild().getSibling());
			root1.getChild().setSibling(root2);
		}
		root1.setChild(root2);
		return root1;
	}

	/**
	 * returns the root of the tree of degree "degree" in the heap if none
	 * returns null
	 */
	private HeapNode findTree(int degree) {
		HeapNode root = this.first;
		if (maxTreeRank() < degree) {
			return null;
		}

		// check each root in the heap
		do {
			if (root.getDegree() == degree) {
				return root;
			}
			if (root.getDegree() > degree) {
				return null;
			}
			root = root.getSibling();
		} while (root != this.first);
		return null;
	}

	/**
	 * public void meld (BinomialHeap heap2)
	 *
	 * Meld the heap with heap2
	 *
	 */
	public void meld(BinomialHeap heap2) {
		if (heap2.empty()) {
			return;
		} else if (empty()) {
			this.first = heap2.first;
			this.min = heap2.min;
			this.size = heap2.size;
		} else {
			int maxdegree = Math.max(maxTreeRank(), heap2.maxTreeRank());
			HeapNode root1, root2, root3 = null;

			for (int i = 0; i < maxdegree + 1; i++) {
				root1 = this.findTree(i);
				root2 = heap2.findTree(i);

			}

			link(min, first);
			if (heap2.findMin() < this.findMin()) {
				this.min = heap2.min;
			}
			this.size += heap2.size;
		}
	}

	/**
	 * public int size()
	 *
	 * Return the number of elements in the heap
	 * 
	 */
	public int size() {
		return this.size;
	}

	/**
	 * public int minTreeRank()
	 *
	 * Return the minimum rank of a tree in the heap.
	 * 
	 */
	public int minTreeRank() {
		int minDegree = this.first.getDegree();
		HeapNode x = this.first.getSibling();
		while (x != this.first) {
			if (x.getDegree() < minDegree) {
				minDegree = x.getDegree();
			}
			x = x.getSibling();
		}
		return minDegree;
	}

	/**
	 * public int maxTreeRank()
	 *
	 * Return the maximum rank of a tree in the heap.
	 * 
	 */
	private int maxTreeRank() {
		int maxDegree = this.first.getDegree();
		HeapNode x = this.first.getSibling();
		while (x != this.first) {
			if (x.getDegree() > maxDegree) {
				maxDegree = x.getDegree();
			}
			x = x.getSibling();
		}
		return maxDegree;
	}

	/**
	 * public boolean[] binaryRep()
	 *
	 * Return an array containing the binary representation of the heap.
	 * 
	 */
	public boolean[] binaryRep() {
		boolean[] arr = new boolean[maxTreeRank() + 1];

		HeapNode x = this.first;
		do {
			arr[x.getDegree()] = true;
			x = x.getSibling();
		} while (x != this.first);
		return arr;
	}

	/**
	 * public void arrayToHeap()
	 *
	 * Insert the array to the heap. Delete previous elemnts in the heap.
	 * 
	 */
	public void arrayToHeap(int[] array) {
		this.first = null;
		this.min = null;
		this.size = 0;

		for (int i = 0; i < array.length; i++) {
			insert(array[i]);
		}
	}

	/**
	 * public boolean isValid()
	 *
	 * Returns true if and only if the heap is valid.
	 * 
	 */
	public boolean isValid() {
		boolean[] degrees = new boolean[maxTreeRank() + 1];

		HeapNode root = this.first;
		// check for each root in the heap
		do {
			// check: the tree is valid binomial tree
			if (!isValidTree(root, root.getDegree())) {
				return false;
			}

			// check: for each i there is only one tree of rank i
			if (degrees[root.getDegree()]) {
				return false;
			}
			degrees[root.getDegree()] = true;

			root = root.getSibling();
		} while (root != this.first);

		return true;
	}

	/**
	 * checks if root (of degree k) is a valid Binomial Tree valid Binomial Tree
	 * = if x is y's parent - x.key < y.key and all children of root are valid
	 * Binomial Trees of degrees 0,...,k-1
	 */
	private boolean isValidTree(HeapNode root, int degree) {
		if (root.getDegree() != degree) {
			return false;
		}

		int key = root.getKey();
		HeapNode child = root.getChild().getSibling();

		for (int i = 0; i < degree; i++) {
			if (child.getKey() < key) {
				return false;
			}
			if (!isValidTree(child, i)) {
				return false;
			}
			child = child.getSibling();
		}
		return true;
	}

	/**
	 * public void delete(int value)
	 *
	 * Delete the element with the given value from the heap, if such an element
	 * exists. If the heap doen't contain an element with the given value, don't
	 * change the heap.
	 *
	 */
	public void delete(int value) {
		decreaseKey(value, -1);
		deleteMin();
	}

	/**
	 * public void decreaseKey(int oldValue, int newValue)
	 *
	 * If the heap doen't contain an element with value oldValue, don't change
	 * the heap. Otherwise decrease the value of the element whose value is
	 * oldValue to be newValue. Assume newValue <= oldValue.
	 */
	public void decreaseKey(int oldValue, int newValue) {
		HeapNode x = hashMap.remove(oldValue);
		hashMap.put(newValue, x);

		x.setKey(newValue);
		HeapNode y = x.getParent();

		while (y != null && x.getKey() < y.getKey()) {
			x.setKey(y.getKey());
			y.setKey(newValue);
			x = y;
			y = y.getParent();
		}

		if (newValue < this.min.getKey()) {
			this.min = x;
		}
	}

	/**
	 * public class HeapNode
	 * 
	 * If you wish to implement classes other than BinomialHeap (for example
	 * HeapNode), do it in this file, not in another file
	 * 
	 */
	public class HeapNode {
		private HeapNode parent;
		private HeapNode child;
		private HeapNode sibling;
		private int key;
		private int degree;

		public HeapNode getParent() {
			return parent;
		}

		public void setParent(HeapNode parent) {
			this.parent = parent;
		}

		public HeapNode getChild() {
			return child;
		}

		public void setChild(HeapNode child) {
			this.child = child;
		}

		public HeapNode getSibling() {
			return sibling;
		}

		public void setSibling(HeapNode sibling) {
			this.sibling = sibling;
		}

		public int getDegree() {
			return degree;
		}

		public void setDegree(int degree) {
			this.degree = degree;
		}

		public int getKey() {
			return this.key;
		}

		public void setKey(int key) {
			this.key = key;
		}

		public HeapNode(int key) {
			this.parent = null;
			this.child = null;
			this.sibling = null;
			this.key = key;
			this.degree = 0;
		}

	}
