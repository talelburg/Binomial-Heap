import java.util.HashMap;

/**
 * BinomialHeap
 *
 * An implementation of binomial heap over non-negative integers. Based on
 * exercise from previous semester.
 */
public class BinomialHeap {
	private static HashMap<Integer, HeapNode> hashMap = new HashMap<>();
	private HeapNode first;
	private HeapNode min;
	private int size;

	public BinomialHeap() {
		this.first = null;
		this.min = null;
		this.size = 0;
	}

	public BinomialHeap(HeapNode first, HeapNode min, int size) {
		this.first = first;
		this.min = min;
		this.size = size;
	}

	/**
	 * public boolean empty()
	 *
	 * precondition: none
	 * 
	 * The method returns true if and only if the heap is empty.
	 * 
	 */
	public boolean empty() {
		return size() == 0;
	}

	/**
	 * public void insert(int value)
	 *
	 * Insert value into the heap
	 *
	 */
	public void insert(int value) {
		HeapNode x = new HeapNode(value);
		x.setSibling(x);
		hashMap.put(value, x);
		BinomialHeap newHeap = new BinomialHeap(x, x, 1);
		meld(newHeap);
	}

	/**
	 * public void deleteMin()
	 *
	 * Delete the minimum value
	 *
	 */
	public void deleteMin() {
		hashMap.remove(this.min.getKey());
		int minSize = (int) Math.pow(2, this.min.getDegree());
		this.size -= minSize;

		HeapNode newFirst, newMin, x;
		BinomialHeap newHeap;

		if (this.min.getChild() != null) {
			newFirst = this.min.getChild().getSibling();
			newMin = newFirst;
			x = newFirst;

			// find the minimum of min's children
			for (int i = 0; i < this.min.getDegree(); i++) {
				x.setParent(null);
				if (x.getKey() < newMin.getKey()) {
					newMin = x;
				}
				x = x.getSibling();
			}

			newHeap = new BinomialHeap(newFirst, newMin, minSize - 1);
		} else {
			// send an empty heap to meld function
			newHeap = new BinomialHeap(null, null, 0);
		}

		if (!this.min.getSibling().equals(this.min)) {
			// find new minimum of the remaining heap

			newMin = this.min.getSibling();
			x = newMin.getSibling();
			do {
				if (x.getKey() < newMin.getKey()) {
					newMin = x;
				}
				x = x.getSibling();
			} while (!x.equals(this.min));

			// if min was first, fix pointer
			if (first.equals(this.min)) {
				this.first = this.first.getSibling();
			}

			// delete sibling pointer to min
			x = this.first;
			while (!x.getSibling().equals(this.min)) {
				x = x.getSibling();
			}
			x.setSibling(this.min.getSibling());

			this.min = newMin;
		} else {
			this.first = null;
			this.min = null;
		}

		meld(newHeap);
	}

	/**
	 * public int findMin()
	 *
	 * Return the minimum value
	 *
	 */
	public int findMin() {
		if (empty()) {
			return -1;
		}
		return this.min.getKey();
	}

	/**
	 * link two binomial trees of the same degree (k-1) and return tree of
	 * degree k
	 * 
	 * if one of them is null return the other
	 */
	private HeapNode link(HeapNode root1, HeapNode root2) {
		if (root1 == null) {
			return root2;
		}
		if (root2 == null) {
			return root1;
		}
		if (root1.getKey() > root2.getKey()) {
			// replace root1 and root2 pointers
			HeapNode temp = root1;
			root1 = root2;
			root2 = temp;
		}
		if (root1.getChild() == null) {
			// if root1 has no children
			root2.setSibling(root2);
		} else {
			root2.setSibling(root1.getChild().getSibling());
			root1.getChild().setSibling(root2);
		}
		root1.setChild(root2);
		root1.setDegree(root1.getDegree() + 1);
		return root1;
	}

	/**
	 * returns the root of the tree of degree "degree" in the heap if none
	 * returns null
	 */
	private HeapNode findTree(int degree) {
		if (degree > maxTreeRank() || degree < minTreeRank()) {
			return null;
		}

		HeapNode root = this.first;
		// check each root in the heap
		do {
			if (root.getDegree() == degree) {
				return root;
			}
			if (root.getDegree() > degree) {
				return null;
			}
			root = root.getSibling();
		} while (!root.equals(this.first));
		return null;
	}

	/**
	 * public void meld (BinomialHeap heap2)
	 *
	 * Meld the heap with heap2
	 *
	 */
	public void meld(BinomialHeap heap2) {
		if (heap2.empty()) {
			return;
		} else if (empty()) {
			this.first = heap2.first;
			this.min = heap2.min;
			this.size = heap2.size;
		} else {
			int maxdegree = Math.max(maxTreeRank(), heap2.maxTreeRank());
			HeapNode root1, root2, root3 = null, newFirst = null, current = null, linked = null, added = null, x;

			for (int i = 0; i < maxdegree + 1; i++) {
				if (this.first == null) {
					x = heap2.first;
					if (x == null) {
						break;
					}
					do {
						current.setSibling(x);
						current = x;
						x = x.getSibling();
					} while (!x.equals(heap2.first));
					break;
				} else if (heap2.first == null) {
					x = this.first;
					do {
						current.setSibling(x);
						current = x;
						x = x.getSibling();
					} while (!x.equals(this.first));

					break;
				}

				added = null;
				root1 = this.findTree(i);
				root2 = heap2.findTree(i);
				root3 = linked;
				linked = null;

				if (root1 != null && root2 != null && root3 != null) {

					if (root1.getSibling().equals(root1)) {
						this.first = null;
					} else {
						x = root1;
						while (!x.getSibling().equals(root1)) {
							x = x.getSibling();
						}
						x.setSibling(root1.getSibling());
						this.first = root1.getSibling();
					}

					if (root2.getSibling().equals(root2)) {
						heap2.first = null;
					} else {
						x = root2;
						while (!x.getSibling().equals(root2)) {
							x = x.getSibling();
						}
						x.setSibling(root2.getSibling());
						heap2.first = root2.getSibling();
					}

					linked = link(root1, root2);

					if (newFirst == null) {
						newFirst = root3;
					} else {
						current.setSibling(root3);
					}
					current = root3;
				} else {
					if (root1 == null) {
						if (root2 != null && root3 != null) {
							if (root2.getSibling().equals(root2)) {
								heap2.first = null;
							} else {
								x = root2;
								while (!x.getSibling().equals(root2)) {
									x = x.getSibling();
								}
								x.setSibling(root2.getSibling());
								heap2.first = root2.getSibling();
							}
							linked = link(root2, root3);

						} else {

							if (root2 != null) {
								if (root2.getSibling().equals(root2)) {
									heap2.first = null;
								} else {
									x = root2;
									while (!x.getSibling().equals(root2)) {
										x = x.getSibling();
									}
									x.setSibling(root2.getSibling());
									heap2.first = root2.getSibling();
								}
							}

							added = link(root2, root3);

						}
					} else if (root2 == null) {
						if (root3 != null) {
							if (root1.getSibling().equals(root1)) {
								this.first = null;
							} else {
								x = root1;
								while (!x.getSibling().equals(root1)) {
									x = x.getSibling();
								}
								x.setSibling(root1.getSibling());
								this.first = root1.getSibling();
							}
							linked = link(root1, root3);

						} else {
							if (root1.getSibling().equals(root1)) {
								this.first = null;
							} else {
								x = root1;
								while (!x.getSibling().equals(root1)) {
									x = x.getSibling();
								}
								x.setSibling(root1.getSibling());
								this.first = root1.getSibling();
							}
							added = root1;

						}
					} else {
						if (root1.getSibling().equals(root1)) {
							this.first = null;
						} else {
							x = root1;
							while (!x.getSibling().equals(root1)) {
								x = x.getSibling();
							}
							x.setSibling(root1.getSibling());
							this.first = root1.getSibling();
						}
						if (root2.getSibling().equals(root2)) {
							heap2.first = null;
						} else {
							x = root2;
							while (!x.getSibling().equals(root2)) {
								x = x.getSibling();
							}
							x.setSibling(root2.getSibling());
							heap2.first = root2.getSibling();
						}
						linked = link(root1, root2);
					}
				}

				if (added != null) {
					if (newFirst == null) {
						newFirst = added;
					} else {
						current.setSibling(added);
					}
					current = added;
				}
			}

			// to add the last one
			if (linked != null) {
				if (newFirst == null) {
					newFirst = linked;
				} else {
					current.setSibling(linked);
				}
				current = linked;
			}

			// to make the list circular
			current.setSibling(newFirst);

			this.first = newFirst;
			if (heap2.findMin() < this.findMin()) {
				this.min = heap2.min;
			}
			this.size += heap2.size;
		}

	}

	/**
	 * public int size()
	 *
	 * Return the number of elements in the heap
	 * 
	 */
	public int size() {
		return this.size;
	}

	/**
	 * public int minTreeRank()
	 *
	 * Return the minimum rank of a tree in the heap.
	 * 
	 */
	public int minTreeRank() {
		if (empty()) {
			return -1;
		}
		return this.first.getDegree();
	}

	/**
	 * public int maxTreeRank()
	 *
	 * Return the maximum rank of a tree in the heap.
	 * 
	 */
	private int maxTreeRank() {
		if (empty()) {
			return -1;
		}

		HeapNode prev = this.first;
		HeapNode x = prev.getSibling();
		do {
			prev = x;
			x = x.getSibling();
		} while (!x.equals(this.first));

		return prev.getDegree();
	}

	/**
	 * public boolean[] binaryRep()
	 *
	 * Return an array containing the binary representation of the heap.
	 * 
	 */
	public boolean[] binaryRep() {
		boolean[] arr = new boolean[maxTreeRank() + 1];

		HeapNode x = this.first;
		do {
			arr[x.getDegree()] = true;
			x = x.getSibling();
		} while (!x.equals(this.first));
		return arr;
	}

	/**
	 * public void arrayToHeap()
	 *
	 * Insert the array to the heap. Delete previous elemnts in the heap.
	 * 
	 */
	public void arrayToHeap(int[] array) {
		this.first = null;
		this.min = null;
		this.size = 0;

		for (int i = 0; i < array.length; i++) {
			insert(array[i]);
		}
	}

	/**
	 * public boolean isValid()
	 *
	 * Returns true if and only if the heap is valid.
	 * 
	 */
	public boolean isValid() {
		if (this.size == 0) {
			return true;
		}
		boolean[] degrees = new boolean[maxTreeRank() + 1];

		HeapNode root = this.first;
		// check for each root in the heap
		do {
			// check: the tree is valid binomial tree
			if (!isValidTree(root, root.getDegree())) {
				return false;
			}

			// check: for each i there is only one tree of rank i
			if (degrees[root.getDegree()]) {
				return false;
			}
			degrees[root.getDegree()] = true;

			root = root.getSibling();
		} while (!root.equals(this.first));

		return true;
	}

	/**
	 * checks if root (of degree k) is a valid Binomial Tree valid Binomial Tree
	 * = if x is y's parent - x.key < y.key and all children of root are valid
	 * Binomial Trees of degrees 0,...,k-1
	 */
	private boolean isValidTree(HeapNode root, int degree) {
		if (root.getDegree() != degree) {
			return false;
		}
		if (degree == 0) {
			return true;
		}
		int key = root.getKey();
		HeapNode child = root.getChild().getSibling();

		for (int i = 0; i < degree; i++) {
			if (child.getKey() < key) {
				return false;
			}
			if (!isValidTree(child, i)) {
				return false;
			}
			child = child.getSibling();
		}
		return true;
	}

	/**
	 * public void delete(int value)
	 *
	 * Delete the element with the given value from the heap, if such an element
	 * exists. If the heap doen't contain an element with the given value, don't
	 * change the heap.
	 *
	 */
	public void delete(int value) {
		decreaseKey(value, -1);
		deleteMin();
	}

	/**
	 * public void decreaseKey(int oldValue, int newValue)
	 *
	 * If the heap doen't contain an element with value oldValue, don't change
	 * the heap. Otherwise decrease the value of the element whose value is
	 * oldValue to be newValue. Assume newValue <= oldValue.
	 */
	public void decreaseKey(int oldValue, int newValue) {
		HeapNode x = hashMap.remove(oldValue);
		hashMap.put(newValue, x);

		x.setKey(newValue);
		HeapNode y = x.getParent();

		while (y != null && x.getKey() < y.getKey()) {
			x.setKey(y.getKey());
			y.setKey(newValue);
			x = y;
			y = y.getParent();
		}

		if (newValue < this.min.getKey()) {
			this.min = x;
		}
	}

	public String toString() {
		return Integer.toBinaryString(size);
	}

	/**
	 * public class HeapNode
	 * 
	 * If you wish to implement classes other than BinomialHeap (for example
	 * HeapNode), do it in this file, not in another file
	 * 
	 */
	public class HeapNode {
		private HeapNode parent;
		private HeapNode child;
		private HeapNode sibling;
		private int key;
		private int degree;

		public HeapNode getParent() {
			return parent;
		}

		public void setParent(HeapNode parent) {
			this.parent = parent;
		}

		public HeapNode getChild() {
			return child;
		}

		public void setChild(HeapNode child) {
			this.child = child;
		}

		public HeapNode getSibling() {
			return sibling;
		}

		public void setSibling(HeapNode sibling) {
			this.sibling = sibling;
		}

		public int getDegree() {
			return degree;
		}

		public void setDegree(int degree) {
			this.degree = degree;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			HeapNode other = (HeapNode) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (key != other.key)
				return false;
			return true;
		}

		public int getKey() {
			return this.key;
		}

		public void setKey(int key) {
			this.key = key;
		}

		public HeapNode(int key) {
			this.parent = null;
			this.child = null;
			this.sibling = null;
			this.key = key;
			this.degree = 0;
		}

		private BinomialHeap getOuterType() {
			return BinomialHeap.this;
		}

		public String toString() {
			return this.getKey() + ", child: " + (this.child == null ? "null" : this.child.getKey()) + ", sibling "
					+ (this.sibling == null ? "null" : this.sibling.getKey());
		}
	}
}
