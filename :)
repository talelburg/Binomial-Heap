import java.util.HashMap;

/**
 * BinomialHeap
 *
 * An implementation of binomial heap over non-negative integers. Based on
 * exercise from previous semester.
 */
public class BinomialHeap {
	private static HashMap<Integer, HeapNode> hashMap = new HashMap<>();
	private HeapNode first;
	private HeapNode min;
	private int size;

	public BinomialHeap() {
		this.first = null;
		this.min = null;
		this.size = 0;
	}

	public BinomialHeap(HeapNode first, HeapNode min, int size) {
		this.first = first;
		this.min = min;
		this.size = size;
	}

	/**
	 * public boolean empty()
	 *
	 * precondition: none
	 * 
	 * The method returns true if and only if the heap is empty.
	 * 
	 */
	public boolean empty() {
		return size() == 0;
	}

	/**
	 * public void insert(int value)
	 *
	 * Insert value into the heap
	 *
	 */
	public void insert(int value) {
		HeapNode x = new HeapNode(value);
		x.setSibling(x);
		hashMap.put(value, x);
		BinomialHeap newHeap = new BinomialHeap(x, x, 1);
		meld(newHeap);
	}

	/**
	 * public void deleteMin()
	 *
	 * Delete the minimum value
	 *
	 */
	public void deleteMin() {
		hashMap.remove(this.min.getKey());
		int minSize = (int) Math.pow(2, this.min.getDegree());
		this.size -= minSize;
		HeapNode newFirst, newMin, x;
		BinomialHeap newHeap;

		if (this.min.getChild() != null) {
			newFirst = this.min.getChild().getSibling();
			newMin = newFirst;
			x = newFirst;

			// find the minimum of min's children
			for (int i = 0; i < this.min.getDegree(); i++) {
				x.setParent(null);
				if (x.getKey() < newMin.getKey()) {
					newMin = x;
				}
				x = x.getSibling();
			}

			newHeap = new BinomialHeap(newFirst, newMin, minSize - 1);
		} else {
			// send an empty heap to meld function
			newHeap = new BinomialHeap(null, null, 0);
		}

		if (!this.min.getSibling().equals(this.min)) {
			// find new minimum of the remaining heap

			newMin = this.min.getSibling();
			x = newMin;
			do {
				if (x.getKey() < newMin.getKey()) {
					newMin = x;
				}
				x = x.getSibling();
			} while (!x.equals(this.min));

			// if min was first, fix pointer
			if (first.equals(this.min)) {
				this.first = this.first.getSibling();
			}

			// delete sibling pointer to min
			x = this.first;
			while (!x.getSibling().equals(this.min)) {
				x = x.getSibling();
			}
			x.setSibling(this.min.getSibling());

			this.min = newMin;
		} else {
			this.first = null;
			this.min = null;
		}

		meld(newHeap);
	}

	/**
	 * public int findMin()
	 *
	 * Return the minimum value
	 *
	 */
	public int findMin() {
		if (empty()) {
			return -1;
		}
		return this.min.getKey();
	}

	/**
	 * link two binomial trees of the same degree (k-1) and return tree of
	 * degree k
	 * 
	 * if one of them is null return the other
	 */
	private HeapNode link(HeapNode root1, HeapNode root2) {
		if (root1 == null) {
			return root2;
		}
		if (root2 == null) {
			return root1;
		}
		if (root1.getKey() > root2.getKey()) {
			// replace root1 and root2 pointers
			HeapNode temp = root1;
			root1 = root2;
			root2 = temp;
		}
		if (root1.getChild() == null) {
			// if root1 has no children
			root2.setSibling(root2);
		} else {
			root2.setSibling(root1.getChild().getSibling());
			root1.getChild().setSibling(root2);
		}
		root1.setChild(root2);
		root2.setParent(root1);
		root1.setDegree(root1.getDegree() + 1);
		return root1;
	}

	/**
	 * returns the root of the tree of degree "degree" in the heap if none
	 * returns null
	 */
	private HeapNode findTree(int degree) {
		if (this.empty()) {
			return null;
		}
		if (degree < this.minTreeRank() || degree > this.maxTreeRank()) {
			return null;
		}
		HeapNode x = this.first;
		do {
			if (x.getDegree() == degree) {
				return x;
			}
			x = x.getSibling();
		} while (!x.equals(this.first));
		return null;
	}

	/**
	 * public void meld (BinomialHeap heap2)
	 *
	 * Meld the heap with heap2
	 *
	 *//*
		 * public void meld(BinomialHeap heap2) { if (heap2.empty()) { return; }
		 * if (this.empty()) { this.first = heap2.first; this.min = heap2.min;
		 * this.size = heap2.size; return; } BinomialHeap h = new
		 * BinomialHeap(); h.first = this.merge(this, heap2); h.min =
		 * (this.min.getKey() < heap2.min.getKey() ? this.min : heap2.min);
		 * h.size = this.size + heap2.size; if (h.first == null) { this.first =
		 * h.first; this.min = h.min; this.size = h.size; return; } HeapNode
		 * prev = null, x = h.first, next = x.getSibling(); while (next != null)
		 * { if (x.getDegree() != next.getDegree() || (next.getSibling() != null
		 * && next.getSibling().getDegree() == x.getDegree())) { prev = x; x =
		 * next; } else if (x.getKey() <= next.getKey()) {
		 * x.setSibling(next.getSibling()); next = link(next, x); } else if
		 * (prev == null) { h.first = next; } else { prev.setSibling(next); x =
		 * link(x, next); x = next; } next = x.getSibling(); } this.first =
		 * h.first; this.min = h.min; this.size = h.size; }
		 * 
		 * public HeapNode merge(BinomialHeap h1, BinomialHeap h2) { if
		 * (h1.empty()) { if (h2.empty()) { return null; } return h2.first; } if
		 * (h2.empty()) { return h1.first; } HeapNode a = h1.first, b =
		 * h2.first; h1.first = (a.getDegree() > b.getDegree() ? b : a); if
		 * (h1.first == null) { return h1.first; } if (h1.first.equals(b)) { b =
		 * a; } a = h1.first; HeapNode x = b; do { if (a.getSibling().equals(b))
		 * { a.setSibling(b); return b; } else if (a.getSibling().getDegree() <
		 * b.getDegree()) { a = a.getSibling(); } else { HeapNode c =
		 * b.getSibling(); b.setSibling(a.getSibling()); a.setSibling(b); a =
		 * a.getSibling(); b = c; } } while (!b.equals(x)); x = b; while
		 * (x.getSibling() != null) { x = x.getSibling(); } x.setSibling(b);
		 * return b; }
		 */
	public void meld(BinomialHeap heap2) {

		if (heap2.empty()) {
			return;
		} else if (empty()) {
			this.first = heap2.first;
			this.min = heap2.min;
			this.size = heap2.size;
		} else {
			HeapNode newMin = (this.findMin() < heap2.findMin() ? this.min : heap2.min);
			int newSize = this.size() + heap2.size();
			int maxDeg = Math.max(maxTreeRank(), heap2.maxTreeRank()) + 1;
			HeapNode root1, root2, root3, carry = null, current = null;
			BinomialHeap newHeap = new BinomialHeap();
			for (int i = 0; i < maxDeg; i++) {
				root1 = this.findTree(i);
				root2 = heap2.findTree(i);
				root3 = carry;
				carry = null;
				if (root1 == null) {
					if (root2 == null) {
						if (root3 != null) {
							if (newHeap.empty()) {
								root3.setSibling(root3);
								newHeap.first = root3;
								current = newHeap.first;
								newHeap.size++;
							} else {
								current.setSibling(root3);
								root3.setSibling(newHeap.first);
								current = current.getSibling();
							}
						}
					} else {
						if (root2.getSibling().equals(root2)) {
							heap2.first = null;
							heap2.min = null;
							heap2.size = 0;
						} else {
							HeapNode x = root2.getSibling();
							while (!x.getSibling().equals(root2)) {
								x = x.getSibling();
							}
							x.setSibling(root2.getSibling());
							heap2.first = root2.getSibling();
							HeapNode min = heap2.first;
							x = heap2.first;
							while (!x.getSibling().equals(heap2.first)) {
								if (x.getKey() < min.getKey()) {
									min = x;
								}
								x = x.getSibling();
							}
							heap2.min = min;
							heap2.size -= Math.pow(2, root2.getDegree());
							root2.setSibling(null);
						}
						if (root3 == null) {
							if (newHeap.empty()) {
								root2.setSibling(root2);
								newHeap.first = root2;
								current = newHeap.first;
								newHeap.size++;
							} else {
								current.setSibling(root2);
								root2.setSibling(newHeap.first);
								current = current.getSibling();
							}
						} else {
							carry = link(root2, root3);
						}
					}
				} else if (root2 == null) {
					if (root1.getSibling().equals(root1)) {
						this.first = null;
						this.min = null;
						this.size = 0;
					} else {
						HeapNode x = root1.getSibling();
						while (!x.getSibling().equals(root1)) {
							x = x.getSibling();
						}
						x.setSibling(root1.getSibling());
						this.first = root1.getSibling();
						HeapNode min = this.first;
						x = this.first;
						while (!x.getSibling().equals(this.first)) {
							if (x.getKey() < min.getKey()) {
								min = x;
							}
							x = x.getSibling();
						}
						this.min = min;
						this.size -= Math.pow(2, root1.getDegree());
						root1.setSibling(null);
					}
					if (root3 == null) {
						if (newHeap.empty()) {
							root1.setSibling(root1);
							newHeap.first = root1;
							current = newHeap.first;
							newHeap.size++;
						} else {
							current.setSibling(root1);
							root1.setSibling(newHeap.first);
							current = current.getSibling();
						}
					} else {
						carry = link(root1, root3);
					}
				} else {
					if (root1.getSibling().equals(root1)) {
						this.first = null;
						this.min = null;
						this.size = 0;
					} else {
						HeapNode x = root1.getSibling();
						while (!x.getSibling().equals(root1)) {
							x = x.getSibling();
						}
						x.setSibling(root1.getSibling());
						this.first = root1.getSibling();
						HeapNode min = this.first;
						x = this.first;
						while (!x.getSibling().equals(this.first)) {
							if (x.getKey() < min.getKey()) {
								min = x;
							}
							x = x.getSibling();
						}
						this.min = min;
						this.size -= Math.pow(2, root1.getDegree());
						root1.setSibling(null);
					}
					if (root2.getSibling().equals(root2)) {
						heap2.first = null;
						heap2.min = null;
						heap2.size = 0;
					} else {
						HeapNode x = root2.getSibling();
						while (!x.getSibling().equals(root2)) {
							x = x.getSibling();
						}
						x.setSibling(root2.getSibling());
						heap2.first = root2.getSibling();
						HeapNode min = heap2.first;
						x = heap2.first;
						while (!x.getSibling().equals(heap2.first)) {
							if (x.getKey() < min.getKey()) {
								min = x;
							}
							x = x.getSibling();
						}
						heap2.min = min;
						heap2.size -= Math.pow(2, root2.getDegree());
						root2.setSibling(null);
					}
					carry = link(root1, root2);
					if (root3 != null) {
						if (newHeap.empty()) {
							root3.setSibling(root3);
							newHeap.first = root3;
							current = newHeap.first;
							newHeap.size++;
						} else {
							current.setSibling(root3);
							root3.setSibling(newHeap.first);
							current = current.getSibling();
						}
					}
				}
			}
			if (carry != null) {
				if (newHeap.empty()) {
					carry.setSibling(carry);
					newHeap.first = carry;
				} else {
					current.setSibling(carry);
					carry.setSibling(newHeap.first);
				}
			}
			this.first = newHeap.first;
			this.size = newSize;
			this.min = newMin;
		}
	}
	/*
	 * public void meld(BinomialHeap heap2) { if (heap2.empty()) { return; }
	 * else if (empty()) { this.first = heap2.first; this.min = heap2.min;
	 * this.size = heap2.size; } else { int maxdegree = Math.max(maxTreeRank(),
	 * heap2.maxTreeRank()); HeapNode root1, root2, root3 = null, newFirst =
	 * null, current = null, linked = null, added = null, x;
	 * 
	 * for (int i = 0; i < maxdegree + 1; i++) { if (this.first == null) { x =
	 * heap2.first; if (x == null) { break; } if (newFirst == null) { newFirst =
	 * x; current = x; } else { do { current.setSibling(x); current = x; x =
	 * x.getSibling(); } while (!x.equals(heap2.first)); break; } } else if
	 * (heap2.first == null) { x = this.first; if (newFirst == null) { newFirst
	 * = x; current = x; } else { do { current.setSibling(x); current = x; x =
	 * x.getSibling(); } while (!x.equals(this.first)); break; } }
	 * 
	 * added = null; root1 = this.findTree(i); root2 = heap2.findTree(i); root3
	 * = linked; linked = null;
	 * 
	 * if (root1 != null && root2 != null && root3 != null) {
	 * 
	 * if (root1.getSibling().equals(root1)) { this.first = null; } else { x =
	 * root1; while (!x.getSibling().equals(root1)) { x = x.getSibling(); }
	 * x.setSibling(root1.getSibling()); this.first = root1.getSibling(); }
	 * 
	 * if (root2.getSibling().equals(root2)) { heap2.first = null; } else { x =
	 * root2; while (!x.getSibling().equals(root2)) { x = x.getSibling(); }
	 * x.setSibling(root2.getSibling()); heap2.first = root2.getSibling(); }
	 * 
	 * linked = link(root1, root2);
	 * 
	 * if (newFirst == null) { newFirst = root3; } else {
	 * current.setSibling(root3); } current = root3; } else { if (root1 == null)
	 * { if (root2 != null && root3 != null) { if
	 * (root2.getSibling().equals(root2)) { heap2.first = null; } else { x =
	 * root2; while (!x.getSibling().equals(root2)) { x = x.getSibling(); }
	 * x.setSibling(root2.getSibling()); heap2.first = root2.getSibling(); }
	 * linked = link(root2, root3);
	 * 
	 * } else {
	 * 
	 * if (root2 != null) { if (root2.getSibling().equals(root2)) { heap2.first
	 * = null; } else { x = root2; while (!x.getSibling().equals(root2)) { x =
	 * x.getSibling(); } x.setSibling(root2.getSibling()); heap2.first =
	 * root2.getSibling(); } }
	 * 
	 * added = link(root2, root3);
	 * 
	 * } } else if (root2 == null) { if (root3 != null) { if
	 * (root1.getSibling().equals(root1)) { this.first = null; } else { x =
	 * root1; while (!x.getSibling().equals(root1)) { x = x.getSibling(); }
	 * x.setSibling(root1.getSibling()); this.first = root1.getSibling(); }
	 * linked = link(root1, root3);
	 * 
	 * } else { if (root1.getSibling().equals(root1)) { this.first = null; }
	 * else { x = root1; while (!x.getSibling().equals(root1)) { x =
	 * x.getSibling(); } x.setSibling(root1.getSibling()); this.first =
	 * root1.getSibling(); } added = root1;
	 * 
	 * } } else { if (root1.getSibling().equals(root1)) { this.first = null; }
	 * else { x = root1; while (!x.getSibling().equals(root1)) { x =
	 * x.getSibling(); } x.setSibling(root1.getSibling()); this.first =
	 * root1.getSibling(); } if (root2.getSibling().equals(root2)) { heap2.first
	 * = null; } else { x = root2; while (!x.getSibling().equals(root2)) { x =
	 * x.getSibling(); } x.setSibling(root2.getSibling()); heap2.first =
	 * root2.getSibling(); } linked = link(root1, root2); } }
	 * 
	 * if (added != null) { if (newFirst == null) { newFirst = added; } else {
	 * current.setSibling(added); } current = added; } }
	 * 
	 * // to add the last one if (linked != null) { if (newFirst == null) {
	 * newFirst = linked; } else { current.setSibling(linked); } current =
	 * linked; }
	 * 
	 * // to make the list circular current.setSibling(newFirst);
	 * 
	 * this.first = newFirst; if (heap2.findMin() < this.findMin()) { this.min =
	 * heap2.min; } this.size += heap2.size; }
	 * 
	 * }
	 */

	/**
	 * public int size()
	 *
	 * Return the number of elements in the heap
	 * 
	 */
	public int size() {
		return this.size;
	}

	/**
	 * public int minTreeRank()
	 *
	 * Return the minimum rank of a tree in the heap.
	 * 
	 */
	public int minTreeRank() {
		if (empty()) {
			return -1;
		}
		return this.first.getDegree();
	}

	/**
	 * public int maxTreeRank()
	 *
	 * Return the maximum rank of a tree in the heap.
	 * 
	 */
	private int maxTreeRank() {
		if (empty()) {
			return -1;
		}

		HeapNode prev = this.first;
		HeapNode x = prev.getSibling();
		do {
			prev = x;
			x = x.getSibling();
		} while (!x.equals(this.first));

		return prev.getDegree();
	}

	/**
	 * public boolean[] binaryRep()
	 *
	 * Return an array containing the binary representation of the heap.
	 * 
	 */
	public boolean[] binaryRep() {
		boolean[] arr = new boolean[maxTreeRank() + 1];

		HeapNode x = this.first;
		do {
			arr[x.getDegree()] = true;
			x = x.getSibling();
		} while (!x.equals(this.first));
		return arr;
	}

	/**
	 * public void arrayToHeap()
	 *
	 * Insert the array to the heap. Delete previous elements in the heap.
	 * 
	 */
	public void arrayToHeap(int[] array) {
		this.first = null;
		this.min = null;
		this.size = 0;

		for (int i = 0; i < array.length; i++) {
			insert(array[i]);
		}
	}

	/**
	 * public boolean isValid()
	 *
	 * Returns true if and only if the heap is valid.
	 * 
	 */
	public boolean isValid() {
		if (this.size == 0) {
			return true;
		}
		boolean[] degrees = new boolean[maxTreeRank() + 1];

		HeapNode root = this.first;
		// check for each root in the heap
		do {
			// check: the tree is valid binomial tree
			if (!isValidTree(root, root.getDegree())) {
				return false;
			}

			// check: for each i there is only one tree of rank i
			if (degrees[root.getDegree()]) {
				return false;
			}
			degrees[root.getDegree()] = true;

			root = root.getSibling();
		} while (!root.equals(this.first));

		return true;
	}

	/**
	 * checks if root (of degree k) is a valid Binomial Tree valid Binomial Tree
	 * = if x is y's parent - x.key < y.key and all children of root are valid
	 * Binomial Trees of degrees 0,...,k-1
	 */
	private boolean isValidTree(HeapNode root, int degree) {
		if (root.getDegree() != degree) {
			return false;
		}
		if (degree == 0) {
			return true;
		}
		int key = root.getKey();
		HeapNode child = root.getChild().getSibling();

		for (int i = 0; i < degree; i++) {
			if (child.getKey() < key) {
				return false;
			}
			if (!isValidTree(child, i)) {
				return false;
			}
			child = child.getSibling();
		}
		return true;
	}

	/**
	 * public void delete(int value)
	 *
	 * Delete the element with the given value from the heap, if such an element
	 * exists. If the heap doen't contain an element with the given value, don't
	 * change the heap.
	 *
	 */
	public void delete(int value) {
		decreaseKey(value, -1);
		deleteMin();
	}

	/**
	 * public void decreaseKey(int oldValue, int newValue)
	 *
	 * If the heap doen't contain an element with value oldValue, don't change
	 * the heap. Otherwise decrease the value of the element whose value is
	 * oldValue to be newValue. Assume newValue <= oldValue.
	 */
	public void decreaseKey(int oldValue, int newValue) {
		HeapNode x = hashMap.remove(oldValue);
		hashMap.put(newValue, x);

		x.setKey(newValue);
		HeapNode y = x.getParent();

		while (y != null && x.getKey() < y.getKey()) {
			x.setKey(y.getKey());
			y.setKey(newValue);
			x = y;
			y = y.getParent();
		}

		if (newValue < this.min.getKey()) {
			this.min = x;
		}
	}

	public String toString() {
		return Integer.toBinaryString(size);
	}

	/**
	 * public class HeapNode
	 * 
	 * If you wish to implement classes other than BinomialHeap (for example
	 * HeapNode), do it in this file, not in another file
	 * 
	 */
	public class HeapNode {
		private HeapNode parent;
		private HeapNode child;
		private HeapNode sibling;
		private int key;
		private int degree;

		public HeapNode getParent() {
			return parent;
		}

		public void setParent(HeapNode parent) {
			this.parent = parent;
		}

		public HeapNode getChild() {
			return child;
		}

		public void setChild(HeapNode child) {
			this.child = child;
		}

		public HeapNode getSibling() {
			return sibling;
		}

		public void setSibling(HeapNode sibling) {
			this.sibling = sibling;
		}

		public int getDegree() {
			return degree;
		}

		public void setDegree(int degree) {
			this.degree = degree;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			HeapNode other = (HeapNode) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (key != other.key)
				return false;
			return true;
		}

		public int getKey() {
			return this.key;
		}

		public void setKey(int key) {
			this.key = key;
		}

		public HeapNode(int key) {
			this.parent = null;
			this.child = null;
			this.sibling = null;
			this.key = key;
			this.degree = 0;
		}

		private BinomialHeap getOuterType() {
			return BinomialHeap.this;
		}

		public String toString() {
			return this.getKey() + ", child: " + (this.child == null ? "null" : this.child.getKey()) + ", sibling "
					+ (this.sibling == null ? "null" : this.sibling.getKey());
		}
	}
}
